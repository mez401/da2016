---
title: "Домашняя работа 1"
author: "Мезенцева Алена"
date: '19 ноября 2016 г '
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Исходные данные

Набор данных об осадках в Канаде с 1960 по 1980 годы: <http://www.stats.uwo.ca/faculty/braun/data/rnf6080.dat>.

## Работа с данными

* Загрузите данные в датафрейм, который назовите data.df.

```{r }
data.df <- read.table("http://www.stats.uwo.ca/faculty/braun/data/rnf6080.dat")
```

* Сколько строк и столбцов в data.df?

```{r }
# Строки:
nrow(data.df)
# Колонки
ncol(data.df)
```

* Получите имена колонок

```{r }
colnames(data.df)
```

* Найдите значение из 5 строки седьмого столбца

```{r }
data.df[5,7]
```

* Напечатайте целиком 2 строку

```{r }
data.df[2,]
```

* Объясните, что делает следующая строка кода names(data.df) <- c("year", "month", "day", seq(0,23)). Воспользуйтесь функциями head и tail, чтобы просмотреть таблицу. Что представляют собой последние 24 колонки?

```{r }
names(data.df) <- c("year", "month", "day", seq(0,23))
# Данная строка переименовывает столбцы.
```

    
```{r }
head(data.df)
tail(data.df)
# Последние 24 колонки - количество осадков в определенное время суток (в часах).
```
    
    
* Добавьте новую колонку с названием daily, в которую запишите сумму крайних правых 24 колонок. Постройте гистограмму по этой колонке. Какие выводы можно сделать?

```{r }
data.df$daily <- rowSums(data.df[,c("0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23")],na.rm=TRUE)
hist(data.df$daily, xlab = "Daily")
# Присутствуют отрицательные результаты, чего быть не должно.
```

* Создайте новый датафрейм fixed.df в котром исправьте замеченную ошибку. Постройте новую гистограмму, поясните почему она более корректна.

```{r }
fixed.df <- data.df
d<-array(dim(fixed.df),dim=c(1,2))
for(i in 1:d[,1]){
for(j in 1:d[,2]){
if(fixed.df[i,j] >= 0) fixed.df[i,j] else fixed.df[i,j]=0
}
}
hist(fixed.df$daily, xlab = "Daily")
# Исключены отрицательные значения.
```

## Синтаксис и типизирование

* Для каждой строки кода поясните полученный результат, либо объясните почему она ошибочна.

```{r }
v <- c("4", "8", "15", "16", "23", "42")
max(v)
sort(v)
#sum(v)
# Создана последовательность символов. Для корректного выполнения функций это должны быть числа:
v <- c(4, 8, 15, 16, 23, 42)
max(v)
sort(v)
sum(v)
```


* Для следующих наборов команд поясните полученный результат, либо объясните почему они ошибочны.

```{r }
v2 <- c("5",7,12)
#v2[2] + v2[3]

df3 <- data.frame(z1="5",z2=7,z3=12)
df3[1,2] + df3[1,3]

l4 <- list(z1="6", z2=42, z3="49", z4=126)
l4[[2]] + l4[[4]]
#l4[2] + l4[4]
# Для последовательности v2 невозможно просуммировать элементы 2 и 3, т.к. элемент 2 является символом. 
# Датафрейм корректно сложил числа, потому что он может содержать переменные разного типа.
# В первом случае для списка числа сложились корректно, а во втором случае сложение невозможно, т.к. в данном случае элементом выступает z2=42, а не 42.
```

    
    
## Работа с функциями и операторами

* Оператор двоеточие создаёт последовательность целых чисел по порядку. Этот оператор — частный случай функции seq(), которую вы использовали раньше. Изучите эту функцию, вызвав команду ?seq. Испольуя полученные знания выведите на экран:

  - Числа от 1 до 10000 с инкрементом 372.
  
```{r }
seq(from = 1, to = 10000, by = 372)
```

  - Числа от 1 до 10000 длиной 50.
  
```{r }
seq(from = 1, to = 10000, by = 50)
```

* Функция rep() повторяет переданный вектор указанное число раз. Объясните разницу между rep(1:5,times=3) и rep(1:5, each=3).

```{r }
rep(1:5,times=3)
rep(1:5, each=3)
# В первом случае весь вектор повторяется 3 раза, а во втором - каждый элемент повторяется 3 раза.
```

    